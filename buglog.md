# Checkpoint 1
* Checkpoint section #, date, bug, solution

## GDT Loading
* 6.1.2 - 3-11-24: The `gdt_desc` in `x86_desc.S` was placed such that it messed up the alignment of the LDT, as well as not being aligned itself. It should be aligned to 2 past a 4-byte boundary (i.e. be 2 mod 4) according to volume 3 section 3.5.1 of the x86 ISA reference manual, that way the "pseudo-descriptor" consists of an aligned 2-byte word followed by an aligned 2-byte doubleword. The fix involved adding padding bytes after either an `.align 4` directive or a similarly aligned previous directive, then the label, then the descriptor.

## Paging (6.1.5)
* 6.1 - 3-14-24: After setting up the gitignore, for some reason it was ignoring new c files in `student-distrib/`, turns out that even if a file should be included according to the gitignore, if a parent directory is set to be ignored (as was the case since the `*` line ignores everything including directories), the file will be ignored (makes since, I just didn't think of the implications when writing the gitignore). The fix just involved adding a `!*/` between the `*` line and the `!*.*` lines, so that directories will not be ignored. The man page for `gitignore` was useful in figuring this out.
* 6.1.5 - 3-14-24: I got an error "warning: useless storage class specifier in empty declaration". This was from not giving a type name in a struct typedef, specifically for `pt_ent_t`. The fix involved just adding the type name at the end of the typedef, whoops.
* 6.1.5 - 3-14-24: In the `read_crn()` functions, it was previously set that the assembly did not clobber anything, but upon reading the ISA manual, it says that moving to/from the control registers leaves the flags in an undefined state, so it should be set to clobber `"cc"`. This luckily didn't manifest as anything, but it potentially could in the future.
* 6.1.5 - 3-14-24: I realized at a later point the I hadn't zero initialized the new page directory/table entries in `paging_init()`, so reserved bits were left undefined (since `pd_ent` and `pt_ent` are stored on the stack). This could potentially lead to issues, since the x86 manual says these bits must be set to zero. The fix just involved setting the `val` field on these structs to zero, zeroing out the whole 32-bit struct.
* 6.1.5 - 3-16-24: The compiler warned about implicit casts from ints to pointers in `paging_no_fault_test`. The solution was to add in explicit pointer casts.
* 6.1.5 - 3-16-24: When writing the tests for paging, I originally wrote the inline assembly to be moving whole 4-byte words in `paging_read/write_test` when it was supposed to just read a byte. Fix involved changing the move from a long move to a byte move.

## `lib.c` Fixes
* 6.1 - 3-14-24: Reading through the `lib.c` code, I noticed that the line wrapping code in `putc()` wouldn't work correctly. If a line was too long, it would wrap to the same line instead of the next, since it calculates `screen_y` after already resetting `screen_x` to be 0. It also had the issue that if newlines were printed pushing the current position past the bottom of the screen, it would then write past the end of video memory, instead of either scrolling the screen or wrapping around to the top of the screen. The fix just involved rewriting the calculation of `screen_x` and `screen_y`, and then if `screen_y` afterwards is past the bottom of the screen, it then scrolls the screen up one line.
* 6.1 - 3-14-24: I forgot to actually decrement `screen_y` when scrolling the screen up, which led to it blanking the whole screen funnily.
* 6.1 - 3-14-24: Several of the functions in `lib.c` have this bug that I encountered in MP2 where the compiler assumes that input registers to inline assembly aren't modified by the assembly, while the MOVS and STOS instructions do modify EDI, and the functions do not revert the value of the register back to what it was at the start. The fix generally involves turning the registers into input/output registers so that the compiler knows that the values might be changed by the assembly. Adding the registers to the clobber list does not work, since the clobber list cannot contain registers used as operands. (The input and output registers must be disjoint from the clobber list.) Also! Funny, the functions return the destination pointer, but that pointer might have been modified over the course of the inline assembly based on how the assembly works plus the assumption I mentioned above. And yep! Can confirm that with `-O3` max optimizations, the compiler just returns the modified EDI instead of the original pointer passed in.
* 6.1 - 3-14-24: Came accross a bug when enabling optimizations while investigating the previous bug where because multiple instances of the inline assembly got placed (presumably because of function inlining), there were duplicate labels in the output assembly that the compiler generated. The solution to this is to add a `%=` suffix to each label in the inline assembly, which the compiler then replaces with a unique number per instance of the inline assembly. (I.e. one inlined instance will use the label `memmove_go1` while another will use the label `memmove_go2`, etc., preventing label clashes.) Also fixed this with the halt loop at the end of `entry()`.

## IDT (6.1.3)
* 6.1.3 - 3-18-24: When testing the keyboard driver, we noticed that when typing fast enough in commit 3d6c662 in the cp1_keyboard branch, the kernel would suddenly freeze, printing a single `S` to the screen. Inspecting with gdb showed that it was stuck in the halt while loop of `exception_handler_all()`, and that the single `S` came from it trying to print the exception error message for vector 40, much higher than the max exception value of 19. Removing the `sti()` from `keyboard_handler()` just caused the whole thing to freeze after printing a single character. Looking over the interrupt handler code in `idt.c/h` showed that the IDT was directly pointing at the C function `keyboard_handler`, which then led to us figuring out this insight:
> What's happening, is that if you type fast enough, the interrupt will fire between the `sti` at the end of the keyboard handler, and the handler returning. Since the handler does not use `iret`, the stack pointer after this 2nd interrupt will not be in the same place as it was at the start of the 2nd interrupt, since `ret` alone does not pop all the values that the CPU pushes on the stack when servicing an interrupt. The `ret` from the first interrupt will then set EIP to some other garbage value from the stack, since it no longer points at the original interrupt's EIP, causing some sort of exception.

The solution was to then switch back to using proper assembly linkage for entry and exit to/from the interrupt handler, using the `iret` instruction, as well as pushing the general purpose registers.
* 6.1.3 - 3-19-24: While writing the test code for the IDT, it seemed to be failing a check for the entries in the IDT. Examining with GDB showed that the IDT was full of trap gates that do not clear the interrupt flag, potentially causing issues since hardware interrupts would then be enabled during the handlers. Fix involved flipping the `reserved3` bit to zero in `init_idt_table()` in `idt.c`.
* 6.1.3 - 3-19-24: The DPL for IDT entry `0x80` (syscall) was never set to 3. Solution: set it to 3 in `init_idt_table()`.

## RTC (6.1.4)
* 6.1.4 - 3-18-24: While trying to implement a panic macro for printing a panic message, It was not properly substituting in the file and line numbers into the string. Turns out macro substitution does not apply to the contents of strings. The solution was to pass them into printf as arguments, similar to the testing macros. Using the stringify operator `#` does not work to turn the value of a macro into a string.

## Keyboard (6.1.4)
* 6.1.4 - 3-19-24: Upon merging the new IRQ system with the keyboard driver, the kernel would freeze after typing a single key, displaying it but otherwise freezing. Inspecting with gdb showed that it was stuck in the while loop of `irq_handler()`, and inspecting the value of `curr` and `*curr` showed that the keyboard linked list was actually a linked loop, where the `next` field of `keyboard_node` pointed to `keyboard_node`, forming an infinite loop. Looking over the `irq_register_handler()` led us to the conclusion that something must be calling it twice, because then it would set the `next` field to the previous head pointer, which is also the new head pointer, linking the loop. `keyboard_init()` seemed fine; it only called the register function once. Inspecting the diff for the rtc/keyboard merge commit showed that a call to `keyboard_init()` was added to `entry()` in `kernel.c`, and I realized that there already was an existing call to it there as well from testing the new IRQ system. And yep, `entry()` currently calls `keyboard_init()` twice. The solution, remove one of the calls, and maybe also add a panic condition to the register function so it does not allow forming loops.

# Checkpoint 2
* Checkpoint section #, date, bug, solution

## Create a Terminal Driver (6.2.1)
* 6.2.1 - 3-23-24: When implementing the 128 char long buffer, I ran across a problem where the user could type in 128 characters but then not be able to return since the last character was already full. They would have to delete the last character and press 'Enter' to be able to move to the next line. To fix this, I made an earlier check in the '**keyboard_handler()**' to see if the index of the buffer was at the last position and if the scancode was for **'Enter'**. If it was, it would use the scancode and do newline. Then I edited the original index range check to instead work for **only indexes 0 through 126 (127) of the buffer**. Basically, the user won't be able to input anything to the last position of the buffer except for **'Enter'**.
* 6.2.1 - 3-23-24: When I tried using the **'Tab'** key and then backspacing after I had added the **'Tab'** key functionality, I would have to backspace four times in order to get to the spot I was at before I pressed **'Tab'**. To fix this, I made a check in my '**keyboard_handler()**' to see if the previous index of the buffer was the **'\t'** char that I had put into the array when 'Tab' was pressed. If it was **'\t'**, then I called **'bksp()'**, which basically replaces the current position with an empty space and moves the cursor back one. I did this four times though, since pressing the **'Backspace'** key should delete all four spaces for a **'Tab'** key.
* 6.2.1 - 3-24-24: It was observed that when Caps Lock was active, pressing the keys in the number row and other special keys did not produce the expected symbols. For example, pressing Shift+1 produced "1" instead of "!". This was due to incorrect logic in the **'keyboard_handler()'**, which used the **'caps_lock_active'** state which didn't cover this specific case. To fix this, I decided to make more arrays that were specific to each case of **shift, caps lock, shift & caps lock, and then neither**. I changed **'scancode_to_capslock_ascii'** and added **'scancode_to_capsshift_ascii'**. Then, I checked which keys were pressed in **'keyboard_handler()'** and based on which were pressed, I grab the scancode from that array.
* 6.2.1 - 3-24-24: When I press **'Enter'** when I am at the last index of the buffer, it does the newline but it takes it down 2 lines instead of 1. The issue was that in '**keyboard_handler()**', the logic for handling the newline character was split across two different conditions. I got rid of the first condition and combined it with the second if to make **'if (buffer_index < BUFFER_SIZE - 1  || (scancode == 0x1C && buffer_index == BUFFER_SIZE - 1))'**, which allowed me to ensure I was only outputting the newline character to the screen once.
* 6.2.1 - 3-24-24: Tab is not able to be pressed when you are less than 4 indexes from the end of the buffer. I changed '**keyboard_handler()**' to allow it to be pressed when **'buffer_index < BUFFER_SIZE - 1'** since in the buffer, tab counts as one char and not four.
* 6.2.1 - 3-25-24: Did not include *"types.h"** into **"fd.h"**, which caused type mismatch errors which applied to every syscall. The solution was just to include **"types.h"** in **"fd.h"**.

* 6.2.1 - 3-25-24: Buffer kept the first two characters permenant. Backspace did not clear these two characters. The fix was to rearrange some logic created in **"keyboard.c"** to decrement the buffer after doing all the changes, and removing the buffer check in **"lib.c"**

* 6.2.1 - 3-25-24: **term_read()** wasn't returning the right number of bytes. the fix was to remove the while loop that was making sure that the end of the buffer has nothing at the end because that was incrementing the number of bytes read, which usually ends up at 128 bytes. So we just needed to just count the number of bytes until the buffer full, or when enter is pressed.

## RTC
* 6.2.3 - 3-25-24: The `rtc_handler` wasn't originally setting the `rtc_int_flag` when an interrupt occured, so it would not return from the `rtc_read` system call. The fix just involved setting the flag to one at some point in the handler.
* 6.2.3 - 3-25-24: The compiler complained about not putting parenthesis around subtraction nested in a bitwise op in `rtc_setrate`. The fix involved changing the `(rate - 1 & rate) != 0` to `((rate - 1) & rate) != 0`.
* 6.2.3 - 3-25-24: `rtc_open` was originally setting the `file_ops` field of the `fd_info` struct to `&directory_fd_driver` due to the code just being copied over from the filesystem driver, causing the wrong file operations to be called. The fix involved just changing it to point at the `rtc_fd_driver` struct instead.
* 6.2.3 - 3-25-24: `rtc_write` was originally returning that it had written zero bytes, when in reality it always writes four bytes.

## Filesystem driver
* 6.2.2 - 3-25-24: In `fs_file_fd_generic_test` in `test.c`, originally, the code for calculating the `offset` for `end == 1` did not handle overflows correctly. The fix involved checking for each operation if the result would overflow, and handling it appropriately (by setting `offset` to 0).

# Checkpoint 3
* Checkpoint section #, date, bug, solution

## Stack Switching
* 4-3-24: In `swtch.c`, I accidentally put `*(void*)(esp+0) = NULL;`, which would dereference the `void` pointer, and assign `NULL` to something of type `void`, instead of assigning to a pointer. The fix just needed an additional asterisk, giving ``*(void**)(esp+0) = NULL;`, which has the correct pointer type after dereferencing.
* 4-3-24: In `swtch.c`, the `make_context` function actually writes to the provided stack, which would override the initial kernel stack if used before the first stack switch. To prevent overriding the existing stack, one should only assign to the `context_t` struct and the Process Control Block instead of to the stack.
* 4-4-24: Not a bug per se, but GDB generally likes having at least a full stack frame for the current C function (including args, old EIP, and old EBP). If this is not the case, certain functionality miiight not work correctly. (This came up when writing `proc_entry` in `process.c`) Simple fix just involves calling into another function and doing all the work there if possible.

## Keyboard
* 4-6-24: For some reason, filling up the buffer and then hitting enter causes no more characters to be printed when typing. It still seems to be jumping to `irq_handler` in GDB. Found the issue, `keyboard_handler` checks that `buffer_index` is less than `BUFFER_SIZE-1` before calling `term_recv_byte`, but it's only in `term_recv_byte` that unused lines get cleared out when the user starts typing the next line. Put in a temporary fix of moving the line clearing when `term_in_flag` is one over to `keyboard_handler` outside of the if statement that was causing the bug. We'll definitely want to revisit this code and review its logic.

## Process Management
* 4-8-24: In `kill_curr_process`, it was not checking whether the file descriptor was actually in use before trying to close it, which would probably cause a page fault upon closing a fd with a null `file_ops` pointer. (Glad I caught this now.) The fix just involved checking the present flag of the `fd_info_t` before trying to close it.

# Checkpoint 3 (after deadline edition)

## Process Management
* 4-8-24: In `proc_entry`, we never set the user `esp` in the iret context to point to the end of the 4MB user page. The user programs do not set their own `esp`'s, so we have to do it for them at program start. The fix is to just set `uctx.esp` to `USER_VMEM_END`.
* 4-15-24: In `syscall_halt` in `process.c`, it should just be treating the `int32_t` as a `uint8_t`, truncating the upper bits and only using the 8 least significant bits. It previously was actually doing a bounds check on the return value, but I noticed that user space typically will just put a `-1` as a `int32_t` as the argument (e.g. when running `return -1;` from `main()`). This caused an exception, since the halt syscall would return an error, and then userspace would run the code after the call, which is garbage values (there's nothing there), leading to an exception at some point. To fix, replace the bounds check in `syscall_halt` with some code to just grab the 8 least significant bits from the argument (e.g. by casting to a `uint8_t` from a `uint32_t`).

## Paging
* 4-9-24: Upon halting and returning to the main shell, it seemed like it was restarting the main shell each time. Since this was probably being caused by an exception in user mode (no other info was printed indicating some other reason), I decided to set a breakpoint in `exception_handler_all` to inspect the `iret_context_user_t` passed in, see if there was any indication of what the exception was. Upon doing so, I saw that the `EIP` was zero before the exception, which most likely ment some sort of page mapping or memory mapping maybe got messed up; either that or the context switching / iret went wrong somewhere. At this point I decided to just step through what was happening, setting my breakpoint to start at `syscall_halt`, just to see what was going on. I then stepped through, and upon switching back to the main shell process, I noticed that in the call to `set_user_page` from `switch_to_process`, `set_user_page` was not using the 4M struct variables in `pd_ent_t`, instead using the 4KB variables. This was fine in `paging_init`, since it only shifted by 12 to set `base`, which would still set it to roughly the right value, but then in `set_user_page` it was using `base`, but shifting by 22. This would cause the base of the 4MB page to be `0x0`, and so this whole time every user page was just being mapped to `0x0`. This didn't manifest, since I guess we were only using parts of the 4MB page at `0x0` that actually did map to physical RAM (as opposed to video memory, which is also in this 4MB physical range). The only issue that manifested was then just that we were using the same physical page for both processes, explaining the jump to `EIP=0x0` since it probably executed some code at a weird offset in the other program. The solution overall was to then have the user 4MB page in `mm.c` actually use the 4MB page variables, including `base_4m`, similar to the 4MB kernel page, instead of `base` and other 4KB paging variables.

## File descriptors
* 4-9-24: Running `syserr` seems to cause page faults in kernel mode sometimes when the process ends. I managed to trace where this was happening by inspecting the `iret_context_base_t` passed in to `exception_handler_all`, and just setting ESP, EBP, and EIP to the values from there (keeping in mind that ESP should just be set to the end of the iret context, since kernel mode exceptions don't push an old ESP value to the iret context), and then letting GDB show me the stack frame. It showed that the exception was happening in `kill_curr_process`, specifically when closing the file descriptors. Inspecting the `fd_info_t` showed that its present bit was set, but the rest of the struct was zero, so it was then trying to dereference a null pointer when accessing the file operations.
* 4-9-24: While then inspecting the above bug, I noticed two issues in `syscall_open`: One was that if we were out of file descriptors, it was not correctly erroring out and returning -1. Fixed by checking if we reached the end of the for loop and returning -1 if so. The other was that if `file_open` returned an error, it was not correctly passing that error back and marking the file descriptor as not present. Fixed by adding an error check on the return value of `file_open`. Neither of these were the issue causing the previous bug, though they did seem to help with passing the tests in `syserr`.
* 4-14-24: When running the `syserr` program, specifically test 5, the `err_unopened` test, the kernel page faults. Inspecting the state before the exception using the new GDB custom commands we wrote showed that it was from `syscall_read`, specfically it was trying to deference the null pointer contained in the `file_ops` field of the `fd_info_t` struct. The struct does indeed have its present bit cleared, so it is fine, and it's just an issue of the syscall not checking that the file descriptor is actually present. The fix just involved adding a check earlier in the function on the present bit of the `fd_info_t` struct. `syscall_write` was also missing such a check.

## Custom GDB commands
* 4-10-24: When writing a GDB command that calls another custom command (`jump_to_pid` calling `jump_to_pcb`), it was giving me an elusive error of
```
A syntax error in expression, near `'.
```
It turned out that this error was caused by using `$arg0` in the argument to another custom command. GDB just directly substitutes the string of the argument in place of `$arg0`, only evaluating it when it is used in another command. However, `$arg0` gets redefined in the sub command, so using `$arg0` in the argument does not work. The fix involved first assigning the argument to a separate variable, and then using that variable as the command's argument.

# Checkpoint 4

## vidmap
* 4-15-24: Got errors in `set_user_page` and `syscall_vidmap` in mm.c about not having the right types for `->`, this was because I was trying to access a member of a pointer to a struct, but the value to the left was the struct itself, not a pointer.
* 4-15-24: During compilation, got an undefined reference error for the user vidmap page table in mm.c, this was because I forgot to actually define the variable, only declaring it as extern in the header, but not defining it in mm.c.
* 4-15-24: After finishing executing `fish`, `info mem` in the QEMU monitor still showed that the vidmap page was mapped, even though it was currently back in the shell. The `vidmap` bit does appear to be cleared on the shell PCB, but the `present` bit is still set on the user video memory page table entry, so the present flag is for some reason not getting cleared on exit. FOUND IT, inspecting the code for switching to a process, `switch_to_process` in `process.c`, it was setting whether the vidmap was present based on the PCB of the process it switched to, not the process it had switched from. To fix, use `curr_pcb` instead of `pcb` for checking the `vidmap` flag in `switch_to_process` after we switched back.

## Ctrl-C (terminate current program)
* 4-15-24: When testing the control C functionality, I noticed that terminating the counter program would cause the first `p` in `program terminated abnormally` to be printed as a space instead. Checking where the CPU was before the keyboard interrupt showed that it was in the middle of scrolling the screen up, specifically in the `memmove` call in `putc` in `lib.c`. Because it got interrupted at this point, `screen_y` remained outside of the screen, so the first character afterwards does not get printed correctly. After that first `p` though, the rest of `putc` then does correctly reset `screen_y`, so it does seem to fix itself. The true fix though, was to wrap each of these calls in a `cli_and_save` / `restore_flags` pair, so that way everything gets updated correctly before an interrupt. (NOTE: We will definitely need to fix bugs like this for scheduling, so it's nice to notice it early.)

## getargs
* 4-15-24: The `syscall_getargs` syscall in `process.c` should be checking that the arguments actually fit in the provided buffer, currently it wasn't, so if the provided buffer provided by userspace was too small, it would overflow the user buffer. To fix, use `strlen` to get the length of the args in the PCB, and then check this against `nbytes`.
* 4-15-24: There were cases where `arg_buffer` in `alloc_process` in `process.c` never had a null terminator `'\0'`if the `cmdline` was longer than `ARG_LENGTH`. The fix involved just always putting a null terminator in `arg_buffer` at index `j`, since `j` will always be less than `ARG_LENGTH` (see comment in `alloc_process` for proof). It'd probably be good for `alloc_process` to instead return `NULL` if the `cmdline` is too big instead of truncating, lemme do that now.
* 4-15-24: I noticed that `cat` was saying that it could not open the given file name when passed no arguments, when it should be saying that it cannot read the arguments, since `getargs` should return `-1` if there are no arguments. The fix just involved checking if `arglen` is zero in `syscall_getargs`.
* 4-15-24: Since we are allowed to treat tabs as four spaces, storing spaces in the keyboard buffer, the correct behaviour for `alloc_process` should be to treat both tabs and spaces as delimiters. Also, because MP3 appendix B says to strip all leading spaces for the argument, it should indeed skip over all the spaces between, not just one. Not sure if it should strip leading spaces from the program name, but reading the execute docs in the appendix in a common sense sort of way would mean the first word is the first one without the separating spaces, so probably. Linux also strips leading spaces from program names, so it should be fine.
* 4-15-24: After adding in the code to skip over leading spaces before the program name, it was saying that the command was not found when testing it. Inspecting with GDB showed that the `prog_name` buffer was being written to at an offset into it, not at the start of the buffer. This was because it was still using the same index for both reading from the `cmdline` and for writing to the `prog_name` buffer, so if it skipped leading spaces, it would still write into the `prog_name` buffer with that leading space offset, when it should be writing to the start of the buffer. The fix involved using a separate index `j` that is initialized to zero at the start of the `prog_name` for loop in `alloc_process` in `process.c`, and using this index when indexing into `prog_name` in the for loop.

# Checkpoint 5

## Multiple terminals
* 4-28-24: The blinking cursor seems to appear and disappear seemingly at random. Some patterns to it: backspacing a character always seems to bring it back, so long as there was a character to backspace. Typing will get rid of it, unless you backspace `n` times and then type less than `n` characters. The bug only starts to appear after ctrl+L is used. \
\
I think I know what the issue is after looking at how ctrl+L currently works. In `term_clear_screen` in `terminal.c`, it currently sets the vga memory to all zeros, when it should actually be setting it to alternating `' '` (the character) and `0x7` (the attribute). Because of the attribute being zero, the cursor does not appear (presumably because the cursor uses the foreground color of the character, which is determined by the attribute). The fix involved changing the `memset` over to a `memset_word` that properly sets each character and attribute, as in the `clear` function in `lib.c`.
* 4-28-24: Running the `fish` program seems to display the fish to all terminals, not just the first one where I'm running it. This does not occur for any other program, so it must be an issue with how vidmap is currently being handled. The issue was that `switch_terminal` in `terminal.c` was calling `set_user_page` (in `mm.c`) before it had updated the `active_terminal_id`, so `set_user_page` was basing its decision of where the video memory page was on the old active terminal ID, not the new one. The fix involved moving the call to `set_user_page` to the end of `switch_terminal`, after `active_terminal_id` gets updated.
* 4-28-24: Reading over the process management code, I noticed that upon killing a process, the parent process's running flag was never set back to 1, so the scheduler wouldn't consider switching to the parent process again. This was fixed by setting it to 1 in `kill_curr_process`.

## Scheduling
* 4-28-24: It's possible that `kill_curr_process` in `process.c` gets called before the first processes are started. To help prevent this from causing issues (e.g. if an interrupt handler does not properly check if the current process is present), `kill_curr_process` now also checks if the process is present, and returns immediately if it is not.
* 4-28-24: After finally allocating all three shells and jumping to the first in `start_terminals` in `terminal.c`, it seems as though only the first terminal's shell is actually running, with the other two terminals remaining blank. The keyboard is still responsive in these terminals, but no shell prompt appears, and no programs run. After setting a breakpoint in `do_schedule` to see if I could catch some evidence for why the other programs didn't seem to be running, I decided to first try stepping through the function. I then noticed that it completely skipped over the while loop instead of finding the next running process, and this was due to the condition of the while loop being checked before it ran the body, not after. The fix involved just turning it from a while loop to a do-while loop.

## RTC Virtualization
* 4-28-24: `fish` seems to hang, stuck in `rtc_read` in `rtc.c`. It does seem that the linked list was set up correctly, with both the `next` and `prev` fields set to `NULL` and the head pointing at the single `rtc_driver_data_t` node. Running `pingpong` seems to imply that it is working, but way *way* too slowly. After suspecting that maybe `rtc_setrate` was being called and lowering the hardware frequency, I set a breakpoint at `rtc_setrate` to see if I could catch where, and yep. I forgot to comment out the call to it in `rtc_open`, lol.
* 4-28-24: Seems `fish` exiting has broken the linked list invariants for the rtc file descriptors. To figure out what was happening, I loaded up GDB, ran `fish` in one terminal, and checked the linked list, starting at the head. The `next` and `prev` pointers all seemed fine. I then went on two start a second `fish` in a different terminal. Checking the linked list now showed that the head seemed fine, the first node seemed fine, but the second node had `NULL` for both the `next` and `prev` pointers, indicating that `rtc_open` wasn't properly initializing `prev`. (It can't be an issue with `rtc_close`, since `rtc_close` hadn't ran yet at all.) And yep, `rtc_open` doesn't set the `prev` pointer of the old head node to point to the new head node. Silly me. The fix just involved checking if the head was non-null, and setting its `prev` pointer to point at the new head if it is.

# Extra Credit

## On Screen Keyboard
* 5-2-24: The screen kept flickering. When on terminal 0, only the on screen keyboard would flicker. For other terminals, it seems like it flickers between the active terminal and terminal 0. After contemplating it a bit, I realized that perhaps it was because the VGA is set to a mode where the VGA addresses are not addressing bytes on the host CPU, but instead are addressing 16 bit int's, using the even/odd mode (as set by the Host Odd/Even Memory Read Addressing Enable bit in the VGA registers). Thus, what I thought was a 4K range of addresses is actually a 2K range in the VGA hardware, hence why it was skipping ahead not one, but two pages, showing terminal 0 instead of the double buffer before it.
